#version 430

layout(binding = 0, r16f) uniform image2D output_texture_0;
layout(binding = 1, r16f) uniform image2D output_texture_1;
layout(binding = 2, r16f) uniform image2D output_texture_2;
layout(binding = 3, r16f) uniform image2D output_texture_3;
layout(binding = 4, r16f) uniform image2D output_texture_4;
layout(binding = 5, r16f) uniform image2D output_texture_5;

uniform sampler2D sketch_sampler_texture_0;
uniform ivec2 sketch_screen_size;
uniform ivec2 sketch_depth_size;
uniform int sketch_render_distance;

#define MIP_LEVELS 6
#define TILE_SIZE_X 16
#define TILE_SIZE_Y 16
#define TILE_EDGE_X TILE_SIZE_X * 2
#define TILE_EDGE_Y TILE_SIZE_Y * 2

layout(local_size_x = TILE_SIZE_X, local_size_y = TILE_SIZE_Y) in;

shared float depthCache[TILE_EDGE_X][TILE_EDGE_Y];

float near = 0.05;
float far  = 16.0;

float LinearizeDepth(float depth) {
    float z = depth * 2.0 - 1.0;
    return (near * far) / (far + near - z * (far - near));
}

void processLevel(int level, ivec2 depthCoords) {
    ivec2 currentSize = sketch_screen_size >> level;
    bool validPixel = depthCoords.x < currentSize.x &&
    depthCoords.y < currentSize.y;

    if (validPixel) {
        ivec2 srcPos = depthCoords * 2;
        float maxDepth = 0.0;
        float depth;

        if (level == 0) {
            maxDepth = LinearizeDepth(texelFetch(sketch_sampler_texture_0, depthCoords, 0).r);
        } else if (level == 1) {
            depth = imageLoad(output_texture_0, srcPos).r;
            maxDepth = depth;
            depth = imageLoad(output_texture_0, srcPos + ivec2(1,0)).r;
            maxDepth = max(maxDepth, depth);
            depth = imageLoad(output_texture_0, srcPos + ivec2(0,1)).r;
            maxDepth = max(maxDepth, depth);
            depth = imageLoad(output_texture_0, srcPos + ivec2(1,1)).r;
            maxDepth = max(maxDepth, depth);
        } else if (level == 2) {
            depth = imageLoad(output_texture_1, srcPos).r;
            maxDepth = depth;
            depth = imageLoad(output_texture_1, srcPos + ivec2(1,0)).r;
            maxDepth = max(maxDepth, depth);
            depth = imageLoad(output_texture_1, srcPos + ivec2(0,1)).r;
            maxDepth = max(maxDepth, depth);
            depth = imageLoad(output_texture_1, srcPos + ivec2(1,1)).r;
            maxDepth = max(maxDepth, depth);
        } else if (level == 3) {
            depth = imageLoad(output_texture_2, srcPos).r;
            maxDepth = depth;
            depth = imageLoad(output_texture_2, srcPos + ivec2(1,0)).r;
            maxDepth = max(maxDepth, depth);
            depth = imageLoad(output_texture_2, srcPos + ivec2(0,1)).r;
            maxDepth = max(maxDepth, depth);
            depth = imageLoad(output_texture_2, srcPos + ivec2(1,1)).r;
            maxDepth = max(maxDepth, depth);
        } else if (level == 4) {
            depth = imageLoad(output_texture_3, srcPos).r;
            maxDepth = depth;
            depth = imageLoad(output_texture_3, srcPos + ivec2(1,0)).r;
            maxDepth = max(maxDepth, depth);
            depth = imageLoad(output_texture_3, srcPos + ivec2(0,1)).r;
            maxDepth = max(maxDepth, depth);
            depth = imageLoad(output_texture_3, srcPos + ivec2(1,1)).r;
            maxDepth = max(maxDepth, depth);
        } else { // level == 5
            depth = imageLoad(output_texture_4, srcPos).r;
            maxDepth = depth;
            depth = imageLoad(output_texture_4, srcPos + ivec2(1,0)).r;
            maxDepth = max(maxDepth, depth);
            depth = imageLoad(output_texture_4, srcPos + ivec2(0,1)).r;
            maxDepth = max(maxDepth, depth);
            depth = imageLoad(output_texture_4, srcPos + ivec2(1,1)).r;
            maxDepth = max(maxDepth, depth);
        }

        if (level == 0) {
            imageStore(output_texture_0, depthCoords, vec4(maxDepth));
        } else if (level == 1) {
            imageStore(output_texture_1, depthCoords, vec4(maxDepth));
        } else if (level == 2) {
            imageStore(output_texture_2, depthCoords, vec4(maxDepth));
        } else if (level == 3) {
            imageStore(output_texture_3, depthCoords, vec4(maxDepth));
        } else if (level == 4) {
            imageStore(output_texture_4, depthCoords, vec4(maxDepth));
        } else { // level == 5
            imageStore(output_texture_5, depthCoords, vec4(maxDepth));
        }
    }

    memoryBarrierImage();
}

void main() {
    ivec2 groupStart = ivec2(gl_WorkGroupID.xy * gl_WorkGroupSize.xy);
    ivec2 depthCoords = groupStart + ivec2(gl_LocalInvocationID.xy);
    far = sketch_render_distance * 64.0;

    for(int level = 0; level < MIP_LEVELS; level++) {
        processLevel(level, depthCoords);
    }
}