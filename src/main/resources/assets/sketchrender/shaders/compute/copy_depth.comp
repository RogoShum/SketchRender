#version 430

layout(binding = 0) uniform writeonly image2D output_texture_0;
layout(binding = 1) uniform writeonly image2D output_texture_1;
layout(binding = 2) uniform writeonly image2D output_texture_2;
layout(binding = 3) uniform writeonly image2D output_texture_3;
layout(binding = 4) uniform writeonly image2D output_texture_4;
layout(binding = 5) uniform writeonly image2D output_texture_5;

uniform sampler2D sketch_sampler_texture_0;
uniform sampler2D sketch_sampler_texture_1;
uniform sampler2D sketch_sampler_texture_2;
uniform sampler2D sketch_sampler_texture_3;
uniform sampler2D sketch_sampler_texture_4;
uniform sampler2D sketch_sampler_texture_5;

uniform ivec2 sketch_screen_size;
uniform ivec2 sketch_depth_size;
uniform int sketch_render_distance;

#define MIP_LEVELS 6
#define TILE_SIZE_X 16
#define TILE_SIZE_Y 16
#define TILE_EDGE_X TILE_SIZE_X * 2
#define TILE_EDGE_Y TILE_SIZE_Y * 2

layout(local_size_x = TILE_SIZE_X, local_size_y = TILE_SIZE_Y) in;

shared float depthCache[TILE_EDGE_X][TILE_EDGE_Y];

float near = 0.05;
float far  = 16.0;

float LinearizeDepth(float depth) {
    float z = depth * 2.0 - 1.0;
    return (near * far) / (far + near - z * (far - near));
}

void processLevel(int level, ivec2 depthCoords) {
    ivec2 currentSize = sketch_screen_size >> (level + 1);
    bool validPixel = depthCoords.x < currentSize.x &&
    depthCoords.y < currentSize.y;

    if (validPixel) {
        ivec2 srcPos = depthCoords * 2;
        /*
        if (level == 0) {
            srcPos = depthCoords;
        }
        */
        ivec2 cachePos = ivec2(gl_LocalInvocationID.xy * 2);
        /*
        if (level == 0) {
            cachePos = ivec2(gl_LocalInvocationID.xy);
        }
        */
        int pixelSize = 2;

        /*
        if (level == 0) {
            pixelSize = 1;
        }
        */


        for(int y = 0; y < pixelSize; y++) {
            for(int x = 0; x < pixelSize; x++) {
                ivec2 loadPos = srcPos + ivec2(x, y);
                if(loadPos.x < (currentSize.x * 2) &&
                loadPos.y < (currentSize.y * 2)) {
                    float depth = 0.0;
                    switch(level) {
                        case 0: depth = LinearizeDepth(texelFetch(sketch_sampler_texture_0, loadPos, 0).r); break;
                        case 1: depth = texelFetch(sketch_sampler_texture_1, loadPos, 0).r; break;
                        case 2: depth = texelFetch(sketch_sampler_texture_2, loadPos, 0).r; break;
                        case 3: depth = texelFetch(sketch_sampler_texture_3, loadPos, 0).r; break;
                        case 4: depth = texelFetch(sketch_sampler_texture_4, loadPos, 0).r; break;
                        case 5: depth = texelFetch(sketch_sampler_texture_5, loadPos, 0).r; break;
                    }
                    depthCache[cachePos.y + y]
                    [cachePos.x + x] = depth;
                }
            }
        }

        float maxDepth = depthCache[cachePos.y][cachePos.x];
        maxDepth = max(maxDepth, depthCache[cachePos.y][cachePos.x + 1]);
        maxDepth = max(maxDepth, depthCache[cachePos.y + 1][cachePos.x]);
        maxDepth = max(maxDepth, depthCache[cachePos.y + 1][cachePos.x + 1]);
        if (level > 0) {

        }

        switch(level) {
            case 0: imageStore(output_texture_0, depthCoords, vec4(maxDepth)); break;
            case 1: imageStore(output_texture_1, depthCoords, vec4(maxDepth)); break;
            case 2: imageStore(output_texture_2, depthCoords, vec4(maxDepth)); break;
            case 3: imageStore(output_texture_3, depthCoords, vec4(maxDepth)); break;
            case 4: imageStore(output_texture_4, depthCoords, vec4(maxDepth)); break;
            case 5: imageStore(output_texture_5, depthCoords, vec4(maxDepth)); break;
        }
    }

    memoryBarrierImage();
}

void main() {
    ivec2 groupStart = ivec2(gl_WorkGroupID.xy * gl_WorkGroupSize.xy);
    ivec2 depthCoords = groupStart + ivec2(gl_LocalInvocationID.xy);
    far = sketch_render_distance * 64.0;

    for(int level = 0; level < MIP_LEVELS; level++) {
        processLevel(level, depthCoords);
    }
}