{
  "shader": "sodium:terrain",
  "type": "vertex",
  "position_regex": "BEFORE_MAIN",
  "content": "                uniform sampler2D sketch_culling_texture;\n                uniform int sketch_culling_terrain;\n                uniform int sketch_level_min_pos;\n                uniform int sketch_level_pos_range;\n                uniform int sketch_level_section_range;\n                uniform int sketch_render_distance;\n                uniform int sketch_space_partition_size;\n                uniform int sketch_culling_size;\n                uniform vec3 sketch_camera_pos;\n                uniform int sketch_check_culling;\n\n                int _map_culling_chunkY(float _pos_y) {\n                    float offset = _pos_y - sketch_level_min_pos;\n                    float mappingRatio = offset / sketch_level_pos_range;\n\n                    return int(floor(mappingRatio * sketch_level_section_range));\n                }\n\n                int _get_chunk_index(ivec3 chunk_offset) {\n                    return (chunk_offset.x + sketch_render_distance) * sketch_space_partition_size * sketch_level_section_range + (chunk_offset.z + sketch_render_distance) * sketch_level_section_range + chunk_offset.y;\n                }\n\n                ivec3 _vec_to_section_pos(vec3 vec) {\n                    return ivec3(int(vec.x) >> 4, int(vec.y) >> 4, int(vec.z) >> 4);\n                }\n\n                ivec2 _get_culling_uv_from_index(ivec3 chunk_offset) {\n                    int screenIndex = _get_chunk_index(chunk_offset);\n\n                    int fragX = screenIndex % sketch_culling_size;\n                    int fragY = screenIndex / sketch_culling_size;\n\n                    return ivec2(fragX, fragY);\n                }\n\n                bool _is_chunk_culled(ivec3 chunk_offset) {\n                    return texelFetch(sketch_culling_texture, _get_culling_uv_from_index(chunk_offset), 0).y <= 0.001;\n                }",
  "replace": false
}