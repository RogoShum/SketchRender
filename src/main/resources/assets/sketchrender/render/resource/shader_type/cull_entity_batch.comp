#version 430

#import "hiz_culling.glsl"

layout(local_size_x = 64) in;

uniform int sketch_levelSectionRange;
uniform int sketch_entityCount;

layout(std430, binding = 0) readonly buffer EntityDataBuffer {
    float entityData[]; // float * 6: center.x, center.y, center.z, size.x, size.y, size.z
};

layout(std430, binding = 1) writeonly buffer CullingResultBuffer {
    uint cullingResult[];
};

shared uint sharedVisible[64];

bool isVisible(vec3 center, vec3 min, vec3 max) {
    vec3 corners[8] = vec3[](
    vec3(min.x, min.y, min.z),
    vec3(max.x, min.y, min.z),
    vec3(min.x, max.y, min.z),
    vec3(max.x, max.y, min.z),
    vec3(min.x, min.y, max.z),
    vec3(max.x, min.y, max.z),
    vec3(min.x, max.y, max.z),
    vec3(max.x, max.y, max.z)
    );

    for(int i = 0; i < 6; i++) {
        bool inside = false;
        for(int j = 0; j < 8 && !inside; j++) {
            inside = dot(sketch_cullingFrustum[i], vec4(corners[j] - sketch_frustumPos, 1.0)) > 0.0;
        }
        if(!inside) return false;
    }
    return true;
}

void main() {
    uint localIndex = gl_LocalInvocationID.x; // 0~63
    uint globalIndex = gl_GlobalInvocationID.x;

    if(globalIndex >= sketch_entityCount) {
        return;
    }

    int dataOffset = int(globalIndex) * 6;

    vec3 center = vec3(entityData[dataOffset], entityData[dataOffset + 1], entityData[dataOffset + 2]);
    float sizeX = entityData[dataOffset + 3];
    float sizeY = entityData[dataOffset + 4];
    float sizeZ = entityData[dataOffset + 5];
    float halfWidth = sizeX * 0.5 + 0.15;
    float halfHeight = sizeY * 0.5 + 0.15;

    bool visible = isVisible(center, center - vec3(halfWidth, halfHeight, halfWidth), center + vec3(halfWidth, halfHeight, halfWidth));
    uint visibleByte = 0u;

    if (visible) {
        far = sketch_renderDistance * 64.0;
        ClipResult clip = getClippedMinDepth(center, halfWidth, halfHeight);
        float sectionDepth = LinearizeDepth(clip.minDepth);

        int idx = getSampler(clip.screenMax.x - clip.screenMin.x, clip.screenMax.y - clip.screenMin.y);

        int depthX = int(sketch_depthSize[idx].x);
        int depthY = int(sketch_depthSize[idx].y);

        int coordMinX = max(int(floor(clip.screenMin.x * depthX)), 0);
        int coordMaxX = min(int(ceil(clip.screenMax.x * depthX)), depthX - 1);
        int coordMinY = max(int(floor(clip.screenMin.y * depthY)), 0);
        int coordMaxY = min(int(ceil(clip.screenMax.y * depthY)), depthY - 1);

        for (int x = coordMinX; x <= coordMaxX; x++) {
            for (int y = coordMinY; y <= coordMaxY; y++) {
                float pixelDepth = getUVDepth(idx, ivec2(x, y));
                if (sectionDepth < pixelDepth) {
                    visibleByte = 1u;
                    break;
                }
            }
            if (visibleByte == 1u) break;
        }
    }

    sharedVisible[localIndex] = visibleByte;
    barrier();

    if (localIndex < 16) {
        uint packedResult = 0u;
        for (uint i = 0; i < 4; ++i) {
            packedResult |= (sharedVisible[localIndex * 4 + i] & 0xFFu) << (i * 8);
        }

        uint groupBase = (gl_WorkGroupID.x * 64) / 4;
        cullingResult[groupBase + localIndex] = packedResult;
    }
}