#version 430

layout(binding = 0, r16f) uniform writeonly image2D output_texture_0;
layout(binding = 1, r16f) uniform writeonly image2D output_texture_1;
layout(binding = 2, r16f) uniform writeonly image2D output_texture_2;
layout(binding = 3, r16f) uniform writeonly image2D output_texture_3;

uniform sampler2D sketch_SamplerTexture;

uniform ivec2 sketch_screenSize;
uniform int sketch_linerDepth;
uniform int sketch_renderDistance;

#define MIP_LEVELS 4
#define TILE_SIZE_X 16
#define TILE_SIZE_Y 16
#define TILE_EDGE_X TILE_SIZE_X * 2
#define TILE_EDGE_Y TILE_SIZE_Y * 2

layout(local_size_x = 16, local_size_y = 16) in;

shared float depthCache[TILE_SIZE_Y * 2][TILE_SIZE_X * 2];
shared float depthCache_[TILE_SIZE_Y * 2][TILE_SIZE_X * 2];

float near = 0.05;
float far  = 16.0;

float LinearizeDepth(float depth) {
    float z = depth * 2.0 - 1.0;
    return (near * far) / (far + near - z * (far - near));
}

void main() {
    ivec2 groupStart = ivec2(gl_WorkGroupID.xy * gl_WorkGroupSize.xy);
    ivec2 localID = ivec2(gl_LocalInvocationID.xy);
    far = sketch_renderDistance * 64.0;

    for (int dy = 0; dy < 2; ++dy) {
        for (int dx = 0; dx < 2; ++dx) {
            ivec2 cachePos = localID * 2 + ivec2(dx, dy);
            ivec2 texPos = min(groupStart * 2 + cachePos, sketch_screenSize);
            float depth = sketch_linerDepth > 0 ? LinearizeDepth(texelFetch(sketch_SamplerTexture, texPos, 0).r) : texelFetch(sketch_SamplerTexture, texPos, 0).r;
            depthCache[cachePos.y][cachePos.x] = depth;
        }
    }
    barrier();

    int mipWidth = TILE_SIZE_X * 2;
    int mipHeight = TILE_SIZE_Y * 2;
    for (int level = 0; level < 4; ++level) {
        int nextWidth = (mipWidth + 1) / 2;
        int nextHeight = (mipHeight + 1) / 2;

        if (level % 2 == 0) {
            if (localID.x < nextWidth && localID.y < nextHeight) {
                int x0 = localID.x * 2;
                int y0 = localID.y * 2;
                float d0 = depthCache[y0][x0];
                float d1 = depthCache[y0][x0 + 1];
                float d2 = depthCache[y0 + 1][x0];
                float d3 = depthCache[y0 + 1][x0 + 1];
                float maxDepth = max(max(d0, d1), max(d2, d3));

                depthCache_[localID.y][localID.x] = maxDepth;
            }
        } else {
            if (localID.x < nextWidth && localID.y < nextHeight) {
                int x0 = localID.x * 2;
                int y0 = localID.y * 2;
                float d0 = depthCache_[y0][x0];
                float d1 = depthCache_[y0][x0 + 1];
                float d2 = depthCache_[y0 + 1][x0];
                float d3 = depthCache_[y0 + 1][x0 + 1];
                float maxDepth = max(max(d0, d1), max(d2, d3));

                depthCache[localID.y][localID.x] = maxDepth;
            }
        }
        barrier();

        ivec2 mipGroupStart = ivec2(gl_WorkGroupID.xy * gl_WorkGroupSize.xy);
        mipGroupStart >>= level;

        ivec2 outPos = mipGroupStart + localID;
        ivec2 outSize = max(sketch_screenSize >> (level + 1), ivec2(1, 1));

        if (outSize.x % 2 == 1) {
            outSize.x += 1;
        }

        if (outSize.y % 2 == 1) {
            outSize.y += 1;
        }

        if (localID.x < nextWidth && localID.y < nextHeight && outPos.x < outSize.x && outPos.y < outSize.y) {
            switch (level) {
                case 0: imageStore(output_texture_0, outPos, vec4(depthCache_[localID.y][localID.x])); break;
                case 1: imageStore(output_texture_1, outPos, vec4(depthCache[localID.y][localID.x])); break;
                case 2: imageStore(output_texture_2, outPos, vec4(depthCache_[localID.y][localID.x])); break;
                case 3: imageStore(output_texture_3, outPos, vec4(depthCache[localID.y][localID.x])); break;
            }
        }
        barrier();

        mipWidth = nextWidth;
        mipHeight = nextHeight;
    }
}