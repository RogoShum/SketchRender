#version 430

#import "hiz_culling.glsl"

struct DrawCommand {
    int element_count;
    int instance_count;
    int first_index;
    int vertex_offset;
    int instance_offset;
};

struct SectionMesh {
    int vertex_offset;
    int element_count;
    int index_offset;
};

struct SectionData {
    int mask;
    int visibility;
    SectionMesh[7] mesh;
};

struct MeshCounter {
    int solidCount;
    int cutoutCount;
    int translucentCount;
};

struct RegionPos {
    ivec3 pos;
    int index;
};

struct SortEntry {
    int originalIndex;
    float value;
    int drawCount;
};

layout(std430, binding = 0) readonly buffer SectionMeshBuffer {
    SectionData section_data[];
};

layout(std430, binding = 1) writeonly buffer DrawCommandBuffer {
    DrawCommand draw_command[];
};

layout(std430, binding = 2) writeonly buffer CounterBuffer {
    MeshCounter counter[];
};

layout(std430, binding = 3) readonly buffer RegionPosBuffer {
    RegionPos region_pos[];
};

layout(std430, binding = 4) writeonly buffer ElementCountBuffer {
    int element_count;
};

//section sort
shared SortEntry sort_entries[256];

uniform int sketch_checkCulling;
uniform int sketch_cullFacing;
uniform int sketch_translucentSort;
uniform ivec3 sketch_cameraOffset;
uniform ivec3 sketch_cameraPos;

#define REGION_SIZE 256
#define LAYER_COUNT 3
#define FACE_COUNT 7

#define REGION_OFFSET REGION_SIZE * LAYER_COUNT
#define LAYER_OFFSET REGION_SIZE

#define MODEL_UNASSIGNED 6
#define MODEL_NEG_Z 5
#define MODEL_NEG_Y 4
#define MODEL_NEG_X 3
#define MODEL_POS_Z 2
#define MODEL_POS_Y 1
#define MODEL_POS_X 0

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

bool isVisible(vec3 center) {
    vec3 min = center - vec3(9.0);
    vec3 max = center + vec3(9.0);
    vec3 corners[8] = vec3[](
    vec3(min.x, min.y, min.z),
    vec3(max.x, min.y, min.z),
    vec3(min.x, max.y, min.z),
    vec3(max.x, max.y, min.z),
    vec3(min.x, min.y, max.z),
    vec3(max.x, min.y, max.z),
    vec3(min.x, max.y, max.z),
    vec3(max.x, max.y, max.z)
    );
    vec4[6] frustum = sketch_cullingFrustum;

    for (int i = 0; i < 6; i++) {
        bool inside = false;
        for (int j = 0; j < 8 && !inside; j++) {
            inside = dot(frustum[i], vec4(corners[j] - sketch_frustumPos, 1.0)) > 0.0;
        }
        if (!inside) return false;
    }
    return true;
}

bool _is_chunk_culled(ivec3 sectionPos) {
    vec3 chunkPos = vec3(sectionPos) * 16;
    chunkPos = vec3(chunkPos.x + 8.0, chunkPos.y + 8.0, chunkPos.z + 8.0);

    if (!isVisible(chunkPos)) {
        return true;
    }

    far = sketch_renderDistance * 64.0;

    ClipResult clip = getClippedMinDepth(chunkPos + sketch_cullingCameraDir, 10.0, 10.0);
    float sectionDepth = LinearizeDepth(clip.minDepth);

    vec2 mins = clamp(clip.screenMin, 0.0, 1.0);
    vec2 maxs = clamp(clip.screenMax, 0.0, 1.0);

    int idx = getSampler(maxs.x - mins.x, maxs.y - mins.y);

    int depthX = int(sketch_depthSize[idx].x);
    int depthY = int(sketch_depthSize[idx].y);

    int coordMinX = max(int(floor(mins.x * depthX)), 0);
    int coordMaxX = min(int(ceil(maxs.x * depthX)), depthX - 1);
    int coordMinY = max(int(floor(mins.y * depthY)), 0);
    int coordMaxY = min(int(ceil(maxs.y * depthY)), depthY - 1);

    for (int x = coordMinX; x <= coordMaxX; x++) {
        for (int y = coordMinY; y <= coordMaxY; y++) {
            float pixelDepth = getUVDepth(idx, ivec2(x, y));
            if (sectionDepth < pixelDepth) {
                return false;
            }
        }
    }

    return true;
}

int lessThan(int a, int b) {
    return int(uint(a - b) >> 31);
}

int greaterThan(int a, int b) {
    return int(uint(b - a) >> 31);
}

int getVisibleFaces(int originX, int originY, int originZ, int chunkX, int chunkY, int chunkZ) {
    int boundsMinX = chunkX << 4;
    int boundsMaxX = boundsMinX + 16;
    int boundsMinY = chunkY << 4;
    int boundsMaxY = boundsMinY + 16;
    int boundsMinZ = chunkZ << 4;
    int boundsMaxZ = boundsMinZ + 16;
    int planes = 1 << MODEL_UNASSIGNED;
    planes |= greaterThan(originX, boundsMinX - 3) << MODEL_POS_X;
    planes |= greaterThan(originY, boundsMinY - 3) << MODEL_POS_Y;
    planes |= greaterThan(originZ, boundsMinZ - 3) << MODEL_POS_Z;
    planes |= lessThan(originX, boundsMaxX + 3) << MODEL_NEG_X;
    planes |= lessThan(originY, boundsMaxY + 3) << MODEL_NEG_Y;
    planes |= lessThan(originZ, boundsMaxZ + 3) << MODEL_NEG_Z;
    return planes;
}

int unpackX(int idx) {
    return idx >> 5 & 7;
}

int unpackY(int idx) {
    return idx >> 0 & 3;
}

int unpackZ(int idx) {
    return idx >> 2 & 7;
}

void compareAndSwap(inout SortEntry a, inout SortEntry b, bool ascending) {
    bool swap = ascending ? (a.value > b.value) : (a.value < b.value);
    if (swap) {
        SortEntry temp = a;
        a = b;
        b = temp;
    }
}

void bitonicSort(bool reverse) {
    uint tid = gl_LocalInvocationID.x;

    for (uint k = 2; k <= 256; k *= 2) {
        for (uint j = k / 2; j > 0; j /= 2) {
            uint ixj = tid ^ j;

            if (ixj > tid) {
                bool ascending = (((tid & k) == 0) != reverse);

                compareAndSwap(sort_entries[tid], sort_entries[ixj], ascending);
            }

            barrier();// sync all threads
        }
    }
}

void main() {
    int dataIndex = int(gl_LocalInvocationID.x);

    int outputIndex = int(gl_WorkGroupID.x);
    int posIndexOffset = outputIndex;
    RegionPos regionQueue = region_pos[posIndexOffset];
    int regionIndex = regionQueue.index;
    ivec3 regionPos = regionQueue.pos;

    int sectionIndex = dataIndex;
    ivec3 sectionPos = ivec3(
    unpackX(sectionIndex) + (regionPos.x),
    unpackY(sectionIndex) + (regionPos.y),
    unpackZ(sectionIndex) + (regionPos.z));

    bool culled = _is_chunk_culled(sectionPos);
    if (sketch_checkCulling > 0) {
        culled = !culled;
    }

    vec3 chunkPos = vec3(sectionPos) * 16;
    chunkPos = vec3(chunkPos.x + 8.0, chunkPos.y + 8.0, chunkPos.z + 8.0);
    float distance = length(vec3(chunkPos - sketch_cameraPos));

    int passIndex = int(gl_WorkGroupID.y);
    int slices = 0;
    sort_entries[dataIndex].originalIndex = dataIndex;
    sort_entries[dataIndex].value = 1e30;
    sort_entries[dataIndex].drawCount = 0;

    int meshOffset = (REGION_OFFSET * regionIndex) + (LAYER_OFFSET * passIndex) + sectionIndex;
    SectionData sectionData = section_data[meshOffset];
    int drawCount = 0;
    SectionMesh[7] drawVertex;

    if (!culled) {
        int sorted = (sketch_translucentSort > 0 && passIndex == 2) ? 1 : 0;
        if (sketch_cullFacing > 0 && sorted == 0) {
            slices = getVisibleFaces(sketch_cameraPos.x, sketch_cameraPos.y, sketch_cameraPos.z, sectionPos.x, sectionPos.y, sectionPos.z);
        } else {
            slices = 127;
        }

        slices &= sectionData.mask;

        if (slices != 0) {
            sort_entries[dataIndex].value = distance;
            int maxElementCount = 0;

            for (int facing = 0; facing < FACE_COUNT; ++facing) {
                int elementCount = sectionData.mesh[facing].element_count;
                maxElementCount += elementCount;
                drawVertex[drawCount].element_count = elementCount;
                drawVertex[drawCount].vertex_offset = sectionData.mesh[facing].vertex_offset;
                drawVertex[drawCount].index_offset = (sectionData.mesh[facing].index_offset * sorted) >> 2;
                drawCount += slices >> facing & 1;
            }
            atomicMax(element_count, maxElementCount);
            sort_entries[dataIndex].drawCount = drawCount;

            int currentCounter = 0;

            if (passIndex == 0) {
                currentCounter = atomicAdd(counter[outputIndex].solidCount, drawCount);
            } else if (passIndex == 1) {
                currentCounter = atomicAdd(counter[outputIndex].cutoutCount, drawCount);
            } else {
                currentCounter = atomicAdd(counter[outputIndex].translucentCount, drawCount);
            }
        }
    }

    barrier();
    bitonicSort(passIndex == 2);
    barrier();

    int myOffset = 0;
    for (int i = 0; i < 256; ++i) {
        if (sort_entries[i].originalIndex == dataIndex) {
            break;
        }

        myOffset += sort_entries[i].drawCount;
    }

    if (drawCount > 0) {
        int outputOffset = (REGION_OFFSET * FACE_COUNT * outputIndex) + (LAYER_OFFSET * FACE_COUNT * passIndex) + myOffset;

        for (int i = 0; i < drawCount; ++i) {
            int offset = i + outputOffset;
            draw_command[offset].element_count = drawVertex[i].element_count;
            draw_command[offset].instance_count = 1;
            draw_command[offset].first_index = drawVertex[i].index_offset;
            draw_command[offset].vertex_offset = drawVertex[i].vertex_offset;
            draw_command[offset].instance_offset = 0;
        }
    }
}