#version 430

layout(binding = 0, r16f) uniform writeonly image2D output_texture_0;

uniform sampler2D sketch_SamplerTexture;

uniform ivec3[8] sketch_depthSize;
uniform ivec2 sketch_screenSize;
uniform int sketch_linerDepth;
uniform int sketch_renderDistance;

#define TILE_SIZE_X 16
#define TILE_SIZE_Y 16
#define TILE_EDGE_X TILE_SIZE_X * 2
#define TILE_EDGE_Y TILE_SIZE_Y * 2

layout(local_size_x = TILE_SIZE_X, local_size_y = TILE_SIZE_Y) in;

shared float depthCache[TILE_SIZE_X * 2][TILE_SIZE_Y * 2];
shared float depthCache_[TILE_SIZE_X][TILE_SIZE_Y];

float near = 0.05;
float far  = 16.0;

float LinearizeDepth(float depth) {
    float z = depth * 2.0 - 1.0;
    return (near * far) / (far + near - z * (far - near));
}

void copyDepth(ivec2 localID, int nextWidth, int nextHeight) {
    if (localID.x < nextWidth && localID.y < nextHeight) {
        int x0 = localID.x * 2;
        int y0 = localID.y * 2;
        float d0 = depthCache[y0][x0];
        float d1 = depthCache[y0][x0 + 1];
        float d2 = depthCache[y0 + 1][x0];
        float d3 = depthCache[y0 + 1][x0 + 1];
        float maxDepth = max(max(d0, d1), max(d2, d3));

        depthCache_[localID.y][localID.x] = maxDepth;
    }
}

void copyDepth_(ivec2 localID, int nextWidth, int nextHeight) {
    if (localID.x < nextWidth && localID.y < nextHeight) {
        int x0 = localID.x * 2;
        int y0 = localID.y * 2;
        float d0 = depthCache_[y0][x0];
        float d1 = depthCache_[y0][x0 + 1];
        float d2 = depthCache_[y0 + 1][x0];
        float d3 = depthCache_[y0 + 1][x0 + 1];
        float maxDepth = max(max(d0, d1), max(d2, d3));

        depthCache[localID.y][localID.x] = maxDepth;
    }
}

void storeDepth(ivec2 groupStart, ivec2 localID, int nextWidth, int nextHeight, int level) {
    ivec2 mipGroupStart = groupStart;
    mipGroupStart >>= level;

    ivec2 outPos = mipGroupStart + localID;
    ivec2 outSize = max(sketch_screenSize >> (level + 1), ivec2(1, 1));

    if (outSize.x % 2 == 1) {
        outSize.x += 1;
    }

    if (outSize.y % 2 == 1) {
        outSize.y += 1;
    }

    if (localID.x < nextWidth && localID.y < nextHeight && outPos.x < outSize.x && outPos.y < outSize.y) {
        outPos.y += sketch_depthSize[level + (1 - sketch_linerDepth) * 4].z;
        imageStore(output_texture_0, outPos, vec4(depthCache_[localID.y][localID.x]));
    }
}

void storeDepth_(ivec2 groupStart, ivec2 localID, int nextWidth, int nextHeight, int level) {
    ivec2 mipGroupStart = groupStart;
    mipGroupStart >>= level;

    ivec2 outPos = mipGroupStart + localID;
    ivec2 outSize = max(sketch_screenSize >> (level + 1), ivec2(1, 1));

    if (outSize.x % 2 == 1) {
        outSize.x += 1;
    }

    if (outSize.y % 2 == 1) {
        outSize.y += 1;
    }

    if (localID.x < nextWidth && localID.y < nextHeight && outPos.x < outSize.x && outPos.y < outSize.y) {
        outPos.y += sketch_depthSize[level + (1 - sketch_linerDepth) * 4].z;
        imageStore(output_texture_0, outPos, vec4(depthCache[localID.y][localID.x]));
    }
}

void main() {
    ivec2 groupStart = ivec2(gl_WorkGroupID.xy * gl_WorkGroupSize.xy);
    ivec2 localID = ivec2(gl_LocalInvocationID.xy);
    ivec2 minScreenCoords = sketch_screenSize - ivec2(1);
    far = sketch_renderDistance * 64.0;
    int yOffset = sketch_linerDepth > 0 ? 0 : sketch_depthSize[3].z;

    for (int dy = 0; dy < 2; ++dy) {
        for (int dx = 0; dx < 2; ++dx) {
            ivec2 cachePos = localID * 2 + ivec2(dx, dy);
            ivec2 texPos = min(groupStart * 2 + cachePos, minScreenCoords);
            texPos.y += yOffset;

            float depth = sketch_linerDepth > 0 ?
            LinearizeDepth(texelFetch(sketch_SamplerTexture, texPos, 0).r) :
            texelFetch(sketch_SamplerTexture, texPos, 0).r;
            depthCache[cachePos.y][cachePos.x] = depth;
        }
    }
    barrier();

    //index 0
    int nextWidth = TILE_SIZE_X;
    int nextHeight = TILE_SIZE_Y;

    copyDepth(localID, nextWidth, nextHeight);
    barrier();
    storeDepth(groupStart, localID, nextWidth, nextHeight, 0);

    //index 1
    nextWidth = nextWidth / 2;
    nextHeight = nextHeight / 2;

    copyDepth_(localID, nextWidth, nextHeight);
    barrier();
    storeDepth_(groupStart, localID, nextWidth, nextHeight, 1);

    //index 2
    nextWidth = nextWidth / 2;
    nextHeight = nextHeight / 2;

    copyDepth(localID, nextWidth, nextHeight);
    barrier();
    storeDepth(groupStart, localID, nextWidth, nextHeight, 2);

    //index 3
    nextWidth = nextWidth / 2;
    nextHeight = nextHeight / 2;

    copyDepth_(localID, nextWidth, nextHeight);
    barrier();
    storeDepth_(groupStart, localID, nextWidth, nextHeight, 3);
}